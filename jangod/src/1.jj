 PARSER_BEGIN(Grammar)   
   
 public class Grammar implements NodeType {   
   
   public ParseTreeNode GetParseTree(InputStream in) throws ParseException   
   
   {   
   
        Grammar parser =new Grammar(in);   
   
        return parser.Expression();   
   
   }   
   
     
   
 }   
   
 PARSER_END(Grammar)   
   
 SKIP :   
   
 {   
   
   " " | "\t" | "\n" | "\r"   
   
 }   
   
 TOKEN :   
   
 {   
   
   < ID: ["a"-"z","A"-"Z","_"] ( ["a"-"z","A"-"Z","_","0"-"9"] )* >   
   
 |  < NUM: ( ["0"-"9"] )+ >   
   
 |  < PLUS:   "+" >   
   
 |  < MINUS:  "-" >   
   
 |  < TIMERS: "*" >   
   
 |  < OVER:   "/" >   
   
 |  < LPAREN: "(" >   
   
 |  < RPAREN: ")" >   
   
 }   
   
     
   
 ParseTreeNode Expression() :   
   
 {   
   
          ParseTreeNode ParseTree = null;   
   
          ParseTreeNode node;   
   
 }   
   
 {                   
   
  ( node=Simple_Expression()   
   
  {   
   
     if(ParseTree == null)   
   
                ParseTree =node;   
   
     else   
   
     {   
   
            ParseTreeNode t;   
   
            t= ParseTree;   
   
            while(t.next != null)   
   
                    t=t.next;   
   
                t.next = node;   
   
     }   
   
  }   
   
 )*   
   
   { return ParseTree;}   
   
   <EOF>   
   
 }   
   
 ParseTreeNode Simple_Expression() :   
   
 {   
   
          ParseTreeNode node;   
   
          ParseTreeNode t;   
   
          int op;   
   
 }   
   
 {   
   
   node=Term(){}   
   
   (   
   
   op=addop() t=Term()   
   
 {   
   
                    ParseTreeNode newNode = new ParseTreeNode();   
   
                    newNode.nodetype = op;   
   
                    newNode.child[0] = node;   
   
                    newNode.child[1] = t;   
   
                    switch(op)   
   
                    {   
   
                             case PlusOP:   
   
                             newNode.name = "Operator: +";   
   
                             break;   
   
                             case MinusOP:   
   
                             newNode.name = "Operator: -";   
   
                             break;   
   
                    }   
   
                    node = newNode;   
   
          }   
   
   )*   
   
   { return node; }   
   
 }   
   
 int addop() : {}   
   
 {   
   
          <PLUS> { return PlusOP; }   
   
 |   <MINUS> { return MinusOP; }   
   
 }   
   
 ParseTreeNode Term() :   
   
 {   
   
          ParseTreeNode node;   
   
          ParseTreeNode t;   
   
          int op;   
   
 }   
   
 {   
   
   node=Factor(){}   
   
   (   
   
   op=mulop() t=Factor()   
   
 {   
   
                    ParseTreeNode newNode = new ParseTreeNode();   
   
                    newNode.nodetype = op;   
   
                    newNode.child[0] = node;   
   
                    newNode.child[1] = t;   
   
                    switch(op)   
   
                    {   
   
                             case TimersOP:   
   
                             newNode.name = "Operator: *";   
   
                             break;   
   
                             case OverOP:   
   
                             newNode.name = "Operator: /";   
   
                             break;   
   
                    }   
   
                    node = newNode;   
   
          }   
   
   )*   
   
   {   
   
        return node;   
   
   }   
   
 }   
   
 int mulop() :{}   
   
 {   
   
          <TIMERS> { return TimersOP; }   
   
          | <OVER> { return OverOP;   }   
   
 }   
   
 ParseTreeNode Factor() :   
   
 {   
   
          ParseTreeNode node;   
   
          Token t;   
   
 }   
   
 {   
   
   t=<ID>   
   
 {   
   
            node=new ParseTreeNode();   
   
            node.nodetype= IDstmt;   
   
            node.name = t.image;   
   
            return node;   
   
          }   
   
   |   
   
   t=<NUM>   
   
   {   
   
       node=new ParseTreeNode();   
   
            node.nodetype= NUMstmt;   
   
            node.name = t.image;   
   
            node.value= Integer.parseInt(t.image);   
   
            return node;   
   
     }   
   
   |   
   
   <LPAREN> node=Simple_Expression() <RPAREN>   
   
    {   
   
          return node;   
   
   }   
   
 } 